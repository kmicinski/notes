Resolving and Exploiting the k-CFA Paradox
Illuminating Functional vs. Object-Oriented Program Analysis
Matthew Might

Yannis Smaragdakis

David Van Horn

University of Utah
might@cs.utah.edu

University of Massachusetts
yannis@cs.umass.edu

Northeastern University
dvanhorn@ccs.neu.edu

Abstract

Both points-to and flow analysis acquire a degree of complexity
for higher-order languages: functional languages have first-class
functions and object-oriented languages have dynamic dispatch;
these features conspire to make call-target resolution depend on the
flow of values, even as the flow of values depends on what targets
are possible for a call. That is, data-flow depends on control-flow,
yet control-flow depends on data-flow. Appropriately, this problem
is commonly called control-flow analysis (CFA).
Shiversâ€™s k-CFA [17] is a well-known family of control-flow
analysis algorithms, widely recognized in both the functional and
the object-oriented world. k-CFA popularized the idea of contextsensitive flow analysis.1 Nevertheless, there have always been annoying discrepancies between the experiences in the application of
k-CFA in the functional and the OO world. Shivers himself notes
in his â€œBest of PLDIâ€ retrospective that â€œthe basic analysis, for any
k > 0 [is] intractably slow for large programsâ€ [16]. This contradicts common experience in the OO setting, where a 1- and 2-CFA
analysis is considered heavy but certainly possible [2, 10].
To make matters formally worse, Van Horn and Mairson [19]
recently proved k-CFA for k â‰¥ 1 to be EXPTIME-complete, i.e.,
non-polynomial. Yet the OO formulations of k-CFA have provably
polynomial complexity (e.g., Bravenboer and Smaragdakis [2] express the algorithm in Datalog, which is a language that can only
express polynomial-time algorithms). This paradox seems hard to
resolve. Is k-CFA misunderstood? Has inaccuracy crept into the
transition from functional to OO?
In this paper we resolve the paradox and illuminate the deep
differences between functional and OO context-sensitive program
analyses. We show that the exact same formulation of k-CFA is
exponential-time for functional programs yet polynomial-time for
OO programs. To ensure fidelity, our proof appeals directly to
Shiversâ€™s original definition of k-CFA and applies it to the most
common formal model of Java, Featherweight Java.
As might be expected, our finding hinges on the fundamental
difference between typical functional and OO languages: the former create implicit closures when lambda expressions are created,
while the latter require the programmer to explicitly â€œcloseâ€ (i.e.,
pass to a constructor) the data that a newly created object can reference. At an intuitive level, this difference also explains why the

Low-level program analysis is a fundamental problem, taking the
shape of â€œflow analysisâ€ in functional languages and â€œpoints-toâ€
analysis in imperative and object-oriented languages. Despite the
similarities, the vocabulary and results in the two communities
remain largely distinct, with limited cross-understanding. One of
the few links is Shiversâ€™s k-CFA work, which has advanced the
concept of â€œcontext-sensitive analysisâ€ and is widely known in both
communities.
Recent results indicate that the relationship between the functional and object-oriented incarnations of k-CFA is not as well
understood as thought. Van Horn and Mairson proved k-CFA for
k â‰¥ 1 to be EXPTIME-complete; hence, no polynomial-time algorithm can exist. Yet, there are several polynomial-time formulations of context-sensitive points-to analyses in object-oriented languages. Thus, it seems that functional k-CFA may actually be a profoundly different analysis from object-oriented k-CFA. We resolve
this paradox by showing that the exact same specification of k-CFA
is polynomial-time for object-oriented languages yet exponentialtime for functional ones: objects and closures are subtly different,
in a way that interacts crucially with context-sensitivity and complexity. This illumination leads to an immediate payoff: by projecting the object-oriented treatment of objects onto closures, we
derive a polynomial-time hierarchy of context-sensitive CFAs for
functional programs.
Categories and Subject Descriptors F.3.2 [Logics and Meanings
of Programs]: Semantics of Programming Languagesâ€”Program
Analysis
General Terms

Algorithms, Languages, Theory

Keywords static analysis, control-flow analysis, pointer analysis,
functional, object-oriented, k-CFA, m-CFA

1.

Introduction

One of the most fundamental problems in program analysis is
determining the entities to which an expression may refer at runtime. In imperative and object-oriented (OO) languages, this is
commonly phrased as a points-to (or pointer) analysis: to which
objects can a variable point? In functional languages, the problem
is called flow analysis [11]: to which expressions can a value flow?

1 Although the k-CFA work is often used as a synonym for â€œk-contextsensitiveâ€ in the OO world, k-CFA is more correctly an algorithm that
packages context-sensitivity together with several other design decisions. In
the terminology of OO points-to analysis, k-CFA is a k-call-site-sensitive,
field-sensitive points-to analysis algorithm with a context-sensitive heap
and with on-the-fly call-graph construction. (LhotaÌk [9] and LhotaÌk and
Hendren [10] are good references for the classification of points-to analysis
algorithms.) In this paper we use the term â€œk-CFAâ€ with this more precise
meaning, as is common in the functional programming world, and not just
as a synonym for â€œk-context-sensitiveâ€. Although this classification is more
precise, it still allows for a range of algorithms, as we discuss later.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. To copy otherwise, to republish, to post on servers or to redistribute
to lists, requires prior specific permission and/or a fee.
PLDIâ€™10, June 5â€“10, 2010, Toronto, Ontario, Canada.
Copyright c 2010 ACM 978-1-4503-0019-3/10/06. . . $10.00

305

the xi in multiple call-sites, we can induce an exponential number
of environments to close this Î»-term:

exact same k-CFA analysis will not yield the same results if a functional program is automatically rewritten into an OO program: the
call-site context-sensitivity of the analysis leads to loss of precision when the values are explicitly copiedâ€”the analysis merges
the information for all paths with the same k-calling-context into
the same entry for the copied data.
Beyond its conceptual significance, our finding pays immediate
dividends: By emulating the behavior of OO k-CFA, we derive a
hierarchy, m-CFA, of polynomial CFA analyses for functional programs. In technical terms, k-CFA corresponds to an abstract interpretation over shared-environment closures, while m-CFA corresponds to an abstract interpretation over flat-environment closures.
m-CFA turns out to be an important instantiation in the space of
analyses described by Jagannathan and Weeks [8].

2.

((Î» (f1 ) (f1 0)(f1 1))
(Î» (x1 )
Â·Â·Â·
((Î» (fn ) (fn 0)(fn 1))
(Î» (xn )
(Î» (z) (z x1 . . . xn )))) Â· Â· Â· )) .
Notice that each xi is bound to 0 and 1, thus there are 2n environments closing the inner Î»-term.
The same behavior is not possible in the object-oriented setting
because creating closures has to be explicit (a fundamental difference of the two paradigms2 ) and the site of closure creation becomes the common calling context for all closed variables.
Figures 1 and 2 demonstrate this behavior for a 1-CFA analysis. (This is the shortest, in terms of calling depth, example that
can demonstrate the difference.) Figure 1 presents the program in
OO form, with explicit closuresâ€”i.e., objects that are initialized
to capture the variables that need to be used later. Figure 2 shows
the same program in functional form. We use a fictional (for Java)
construct lambda that creates a closure out of the current environment. The bottom parts of both figures show the information that
the analysis computes. (We have grouped the information in a way
that is more reflective of OO k-CFA implementations, but this is
just a matter of presentation.)
The essential question is â€œin how many environments does function baz get analyzed?â€ The exact same, abstract-interpretationbased, 1-CFA algorithm produces O(N + M ) environments for
the object-oriented program and O(N M ) environments for the
functional program. The reason has to do with how the contextsensitivity of the analysis interacts with the explicit closure. Since
closures are explicit in the OO program, all (heap-)accessible variables were closed simultaneously. One can see this in terms of variables x and y: both are closed by copying their values to the x and y
fields of an object in the expression â€œnew ClosureXY(x,y)â€. This
copying collapses all the different values for x that have the same
1-call-site context. Put differently, x and y inside the OO version of
baz are not the original variables but, rather, copies of them. The
act of copying, however, results in less precision because of the finite context-sensitivity of the analysis. In contrast, the functional
program makes implicit closures in which the values of x and y are
closed at different times and maintain their original context. The
abstract interpretation results in computing all O(N M ) combinations of environments with different contexts for x and y. (If the
example is extended to more levels, the number of environments
becomes exponential in the length of the program.)
The above observations immediately bring to mind a wellknown result in the compilation of functional languages: the choice
between shared environments and flat environments [1, page 142].
In a flat environment, the values of all free variables are copied into
a new environment upon allocation. In a flat-environment scenario,
it is sufficient to know only the base address of an environment to
look up the value of a variable. To define the meaning of a program,
it clearly makes no difference which environment representation a
formal semantics models. However, in compilation there are tradeoffs: shared environments make closure-creation fast and variable
look-up slow, while flat environments make closure-creation slow
and variable look-up fast. The choice of environment representation
also makes a profound difference during abstract interpretation.

Background and Illustration

Although we prove our claims formally in later sections, we first
illustrate the behavior of k-CFA for OO and functional programs
informally, so that the reader has an intuitive understanding of the
essence of our argument.
2.1

Background: What is CFA?

k-CFA was developed to solve the higher-order control-flow problem in Î»-calculus-based programming languages. Functional languages are explicitly vulnerable to the higher-order control-flow
problem, because closures are passed around as first-class values.
Object-oriented languages like Java are implicitly higher-order,
because method invocation is resolved dynamicallyâ€”the invoked
method depends on the type of the object that makes it to the invocation point.
In practice, CFAs must compute much more than just controlflow information. CFAs are also data-flow analyses, computing
the values that flow to any program expression. In the objectoriented setting, CFA is usually termed a â€œpoints-toâ€ analysis and
the interplay between control- and data-flow is called â€œon-the-fly
call-graph constructionâ€ [9].
Both the functional community and the pointer-analysis community have assigned a meaning to the term k-CFA. Informally,
k-CFA refers to a hierarchy of global static analyses whose contextsensitivity is a function of the last k call sites visited. In its functional formulation, k-CFA uses this context-sensitivity for every
value and variableâ€”thus, in pointer analysis terms, k-CFA is a kcall-site-sensitive analysis with a k-context-sensitive heap.
2.2

Insight and Example

The paradox prompted by the Van Horn and Mairson proofs seems
to imply that k-CFA actually refers to two different analyses: one
for functional programs, and one for object-oriented/imperative
programs. The surprising finding of our work is that k-CFA means
the same thing for both programming paradigms, but that its behavior is different for the object-oriented case.
k-CFA was defined by abstract interpretation of the Î»-calculus
semantics for an abstract domain collapsing data values to static
abstractions qualified by k calling contexts. Functional implementations of the algorithm are often heavily influenced by this abstract
interpretation approach. The essence of the exponential complexity
of k-CFA (for k â‰¥ 1) is that, although each variable can appear
with at most O(nk ) calling contexts, the number of variable environments is exponential, because an environment can combine variables from distinct calling contexts. Consider the following term:
(Î» (z) (z x1 . . . xn )) .

2 It is, of course, impossible to strictly classify languages by paradigm

This expression has n free variables. In 1-CFA, each variable is
mapped to the call-site in which it was bound. By binding each of

(â€œwhat is JavaScript?â€) so our statements reflect typical, rather than universal, practice.

306

Environment:

ox1 = new Object(); â€¦ oxN = new Object();

caller() {
foo(ox1);
...
foo(oxN);
}

â€¦

foo(Object x) {
ClosureX cx =
new ClosureX(x);
cx.bar(oy1);
...
cx.bar(oyM);
}

oy1 = newObject(); â€¦ oyM = new Object();

class ClosureX {
Object x;
ClosureX(Object x0) {
x = x0;
} // constructor
bar(Object y) {
ClosureXY cxy =
new ClosureXY(x,y);
cxy.baz(â€¦);
...
}

â€¦

caller@1: foo_x -> [ox1]

heap object
pointsâ€to info

baz(â€¦) {
... x ... y ...
}
}

}

local variable
pointsâ€to info

class ClosureXY {
Object x,y;
ClosureXY(Object x0,
Object y0) {
x = x0; y = y0;
} // constructor

foo@1: bar_y -> [oy1]

...

...

caller@N: foo_x -> [oxN]

foo@M: bar_y -> [oyM]

caller@1:
foo::ClosureX.x -> [ox1]

foo@1:
bar::ClosureXY.x -> [ox1, â€¦, oxN]
bar::ClosureXY.y -> [oy1]

...
caller@N:
foo::ClosureX.x -> [oxN]

O(N+M)
environments

...
foo@M:
bar::ClosureXY.x -> [ox1, â€¦, oxN]
bar::ClosureXY.y -> [oyM]

Figure 1. An example OO program, analyzed under 1-CFA. Parts that are orthogonal to the analysis (e.g., return types, the class containing
foo, the body of baz) are elided. The bottom part shows the (points-to) results of the analysis in the form â€œcontext: var -> abstractObjectâ€.
Conventions: we use [ox1], ..., [oxN], [oy1], ..., [oyM] to mean the abstract objects pointed to by the corresponding environment variables.
(We only care that these objects be distinct.) method var names a local variable, var inside a method. method::Type.field refers to a field of
the object of type Type allocated inside method. (This example allocates a single object per method, so no numeric distinction of allocation
sites is necessary.) callermethod@num designates the num-th call-site inside method callermethod.
caller() {
foo(ox1);
...
foo(oxN);
}

â€¦

foo(Object x) {
Closure cx =
cx(oy1);
...
cx(oyM);

â€¦

lambda(Object y) {
Closure cxy =
cxy(â€¦);
...

}
}
caller@1: foo_x -> [ox1]

local variable
pointsâ€to info

heap object
pointsâ€to info

lambda(â€¦) {
... x ... y ...
}

foo@1: lambda_y -> [oy1]

...

...

caller@N: foo_x -> [oxN]

foo@M: lambda_y -> [oyM]

caller@1:
foo_cx.x -> [ox1]

caller@1: lambda_cxy.x -> [ox1]
foo@1: lambda_cxy.y -> [oy1]

...
caller@N:
foo_cx.x -> [oxN]

O(N*M)
environments

...
caller@N: lambda_cxy.x -> [oxN]
foo@1: lambda_cxy.y -> [oy1]
...
caller@N: lambda_cxy.x -> [oxN]
foo@M: lambda_cxy.y -> [oyM]

Figure 2. The same program in functional form (implicit closures). The lambda expressions are drawn outside their lexical environment to
illustrate the analogy with the OO code. The number of environments out of the abstract interpretation is now O(N M ) because variables x
and y in the rightmost lambda were not closed together and have different contexts.

307

lam âˆˆ Lam ::= (Î» (v1 . . . vn ) call)`
call âˆˆ Call ::= (f e1 . . . en )`

In CPS, there is only one rule to transition from one state to another;
when call = [[(f e1 . . . en )` ]]:

v âˆˆ Var
f, e âˆˆ Exp = Var + Lam

(call , Î², Ïƒ, t) â‡’ (call 0 , Î² 00 , Ïƒ 0 , t0 ), where

` âˆˆ Lab is a set of labels

(lam, Î² 0 ) = E(f, Î², Ïƒ)

di = E(ei , Î², Ïƒ)
0 `0

Figure 3. Grammar for CPS

t0 = tick(call, t)

lam = [[(Î» (v1 . . . vn ) call ) ]]
0

Î² 00 = Î² 0 [vi 7â†’ ai ]

ai = alloc(vi , t )
0

Ïƒ = Ïƒ[ai 7â†’ di ].

3.

Shiversâ€™s original k-CFA

There are two external parameters to this semantics, a function for
incrementing the current time-stamp and a function for allocating
fresh addresses for bindings:

Because one possible resolution to the paradox is that k-CFA for
object-oriented programs and k-CFA for the Î»-calculus is just a
case of using the same name for two different concepts, we need to
be confident that the analysis we are working with is really k-CFA.
To achieve that confidence, we return to the source of k-CFAâ€”
Shiversâ€™s dissertation [17], which formally and precisely pins down
its meaning. We take only cosmetic liberties in reformulating Shiversâ€™s k-CFAâ€”we convert from a tail-recursive denotational semantics to a small-step operational semantics, and we rename contours
to times. Though equivalent, Shiversâ€™s original formulation of kCFA differs significantly from later ones; readers familiar with only
modern CFA theory may even find it unusual. Once we have reformulated k-CFA, our goal will be to adapt it as literally as possible
to Featherweight Java.
3.1

tick : Call Ã— Time â†’ Time
alloc : Var Ã— Time â†’ Addr

It is possible to define a semantics in which the tick function does
not have access to the current call site, but providing access to the
call site will end up simplifying the proof of soundness for k-CFA.
Naturally, we expect that new time-stamps and addresses are
always unique; formally:
t < tick(call, t).

(1)

0

0

If v 6= v , then alloc(v, t) 6= alloc(v , t).

(2)

If t 6= t0 , then alloc(v, t) 6= alloc(v 0 , t0 ).

(3)

For the sake of understanding the concrete semantics, the obvious
solution to these constraints is to use the natural numbers for time:

A grammar for CPS

Addr = Var Ã— Time,

Time = N

A minimal grammar for CPS (Figure 3) contains two expression
formsâ€”Î»-terms and variablesâ€”and one call form. The body of
every Î»-term is a call site, which ensures the CPS constraint that
functions cannot directly return to their callers. We also attach a
unique label to every Î»-term and call site.

so that the tick function merely has to increment:
tick ( , t) = t + 1

alloc(v, t) = (v, t).

3.3 Executing the concrete semantics
The concrete semantics finds the set of states reachable from the
initial state. The system-space for this process is a set of states:

3.2 Concrete semantics for CPS
We model the semantics for CPS as a small-step state machine.
Each state in this machine contains the current call site, a binding
environment in which to evaluate that call, a store and a time-stamp:

Î¾ âˆˆ Îž = P (Î£).

The system-space exploration function is f : Îž â†’ Îž, which maps
a set of states to their successors plus the initial state:
Ë˜
Â¯
f (Î¾) = Ï‚ 0 : Ï‚ âˆˆ Î¾ and Ï‚ â‡’ Ï‚ 0 âˆª {Ï‚0 } ,

Ï‚ âˆˆ Î£ = Call Ã— BEnv Ã— Store Ã— Time

Because the function is monotonic, there exists a fixed point

Î² âˆˆ BEnv = Var * Addr
Ïƒ âˆˆ Store = Addr * D

S=

d âˆˆ D = Clo

âˆž
G

f n (âˆ…),

n=0

clo âˆˆ Clo = Lam Ã— BEnv

which is the (possibly infinite) set of reachable states.

a âˆˆ Addr is an infinite set of addresses

3.4 Abstract semantics for CPS: k-CFA
The development of the abstract semantics parallels the construction of the concrete semantics. The abstract state-space is structurally similar to the concrete semantics:

t âˆˆ Time is an infinite set of time-stamps.

Environments in this state-space are factored; instead of mapping
a variable directly to a value, a binding environment maps a variable to an address, and then the store maps addresses to values.
The specific structure of both time-stamps and addresses will be
determined later. Any infinite set will work for either addresses or
time-stamps for the purpose of defining the meaning of the concrete
semantics. (Specific choices for these sets can simplify proofs of
soundness, which is why they are left unfixed for the moment.)
To inject a call site call into an initial state, we pair it with an
empty environment, an empty store and a distinguished initial time:

\ Ã— Store
[ Ã— Time
\
Ï‚Ë† âˆˆ Î£Ì‚ = Call Ã— BEnv
[
\ = Var â†’ Addr
Î²Ì‚ âˆˆ BEnv
[ â†’ DÌ‚
[ = Addr
ÏƒÌ‚ âˆˆ Store
â€œ
â€
d
dË† âˆˆ DÌ‚ = P Clo
c âˆˆ Clo
d = Lam Ã— BEnv
\
clo
[ is a finite set of addresses
aÌ‚ âˆˆ Addr

Ï‚0 = (call, [], [], t0 ).

\ is a finite set of time-stamps.
tÌ‚ âˆˆ Time

The concrete semantics are composed of an evaluator for expressions and a transition relation on states:
E : Exp Ã— BEnv Ã— Store * D

There are three major distinctions with the concrete state-space:
(1) the set of time-stamps is finite; (2) the set of addresses is finite;
and (3) the store can return a set of values. We assume the natural
partial order (v) on this state-space and its components, along with
the associated meaning for least-upper bound (t). For example:

(â‡’) âŠ† Î£ Ã— Î£.

The evaluator looks up variables, and creates closures over Î»-terms:
E(v, Î², Ïƒ) = Ïƒ(Î²(v))

ÏƒÌ‚ t ÏƒÌ‚ 0 = Î»aÌ‚.(ÏƒÌ‚(aÌ‚) âˆª ÏƒÌ‚ 0 (aÌ‚)).

E(lam, Î², Ïƒ) = (lam, Î²).

308

In theory, k-CFA is able to distinguish up to |Call|k instances
(variants) of each variableâ€”one for each invocation context. Of
course, in practice, each variable tends to be bound in only a small
fraction of all possible invocation contexts. Under this allocation
regime, the external parameters are easily fixed:

A state-wise abstraction map Î± : Î£ â†’ Î£Ì‚ formally relates the
concrete state-space to the abstract state-space:
Î±(call, Î², Ïƒ, t) = (call, Î±(Î²), Î±(Ïƒ), Î±(t))
Î±(Î²) = Î»v.Î±(Î²(v))
G
Î±(Ïƒ) = Î»aÌ‚.
Î±(Ïƒ(a))

tick (call, t) = call : t

Î±(a)=aÌ‚

which leaves only one possible choice for the abstraction maps:

d
Î±(t) is fixed by tick.

Î±(t) = first k (t)

We cannot choose an abstraction for addresses and time-stamps
[.
\ Addr and Addr
until we have chosen the sets Time, Time,
The initial abstract state for a program call is the direct abstraction of the initial concrete state:

3.6 Computing k-CFA naÄ±Ìˆvely
k-CFA can be computed naÄ±Ìˆvely by finding the set of reachable
states. The â€œsystem-spaceâ€ for this approach is a set of states:

The abstract semantics has an expression evaluator:
\ Ã— Store
[ â†’ DÌ‚
EÌ‚ : Exp Ã— BEnv

â€œ â€
Î¾Ì‚ âˆˆ ÎžÌ‚ = P Î£Ì‚ .

EÌ‚(lam, Î²Ì‚, ÏƒÌ‚) = {(lam, Î²Ì‚)}.

The transfer function for this system-space is fË† : ÎžÌ‚ â†’ ÎžÌ‚:

The abstract transition relation (;) âŠ† Î£Ì‚ Ã— Î£Ì‚ mimics its
concrete counterpart as well; when call = [[(f e1 . . . en )` ]]:
0

00

0

fË†(Î¾Ì‚) = {Ë†
Ï‚ 0 : Ï‚Ë† âˆˆ Î¾Ì‚ and Ï‚Ë† ; Ï‚Ë†0 } âˆª {Ë†
Ï‚0 } .

0

(call , Î²Ì‚, ÏƒÌ‚, tÌ‚) ; (call , Î²Ì‚ , ÏƒÌ‚ , tÌ‚ ), where
(lam, Î²Ì‚ 0 ) âˆˆ EÌ‚(f, Î²Ì‚, ÏƒÌ‚)

The size of the state-space bounds the complexity of naÄ±Ìˆve k-CFA:3

dË†i = EÌ‚(ei , Î²Ì‚, ÏƒÌ‚)
0

lam = [[(Î» (v1 . . . vn ) call 0 )` ]]
[ i , tÌ‚0 )
aÌ‚i = alloc(v
0
ÏƒÌ‚ = ÏƒÌ‚ t [aÌ‚i 7â†’ dË†i ].

[
|Store|

\|
\
|BEnv
z
}|
{ |Time|
z
}|
{ â€œ
z }| {
k
â€
kÃ—|Var| |Var|Ã—|Call|
|Call| Ã— |Call|kÃ—|Var| Ã— 2|Lam|Ã—|Call|
Ã— |Call|k

d
tÌ‚0 = tick(call,
tÌ‚)
Î²Ì‚ 00 = Î²Ì‚ 0 [vi 7â†’ aÌ‚i ]

Even for k = 0, this method is deeply exponential, rather than the
expected cubic time more commonly associated with 0CFA.

Notable differences are the fact that this rule is non-deterministic
(it branches to every abstract closure to which the function f evaluates), and that every abstract address could represent several concrete addresses, which means that additions to the store must be
performed with a join operation (t) rather than an extension. There
are also external parameters for the abstract semantics corresponding to the external parameters of the concrete semantics:

3.7 Computing k-CFA with a single-threaded store
Shiversâ€™s technique for making k-CFA more efficient uses one store
to represent all stores. Any set of stores may be conservatively approximated by their least-upper-bound. Under this approximation,
the system-space needs only one store:

d : Call Ã— Time
\ â†’ Time
\
tick

â€œ
â€
\ Ã— Time
\ Ã— Store.
[
ÎžÌ‚ = P Call Ã— BEnv

[ : Var Ã— Time
[
\ â†’ Addr
alloc

Over this system-space, the transfer function becomes:
fË†(CÌ‚, ÏƒÌ‚) = (CÌ‚ âˆª CÌ‚ 0 , ÏƒÌ‚ 0 )
n
o
SÌ‚ 0 = Ï‚Ë†0 : cÌ‚ âˆˆ CÌ‚ and (cÌ‚, ÏƒÌ‚) ; Ï‚Ë†0
n
o
CÌ‚ 0 = cÌ‚ : (cÌ‚, ÏƒÌ‚) âˆˆ SÌ‚ 0
G
ÏƒÌ‚.
ÏƒÌ‚ 0 =

d function allocates an abstract time, which is allowed to
The tick
be an abstract time which has been allocated previously; the allo[ is similarly allowed to re-allocate previously-allocated
cator alloc
addresses.
3.5

Î±(v, t) = (v, Î±(t)).

d determines the context-sensitivity of the
In technical terms, tick
[
analysis, and alloc determines its polyvariance.

Ï‚Ë†0 = Î±(Ï‚0 ) = (call, âŠ¥, âŠ¥, Î±(t0 )).

EÌ‚(v, Î²Ì‚, ÏƒÌ‚) = ÏƒÌ‚(Î²Ì‚(v))

[
alloc(v,
tÌ‚) = (v, tÌ‚),

alloc(v, t) = (v, t)

Î±(lam, Î²) = {(lam, Î±(Î²))}
[
Î±(a) is fixed by alloc

d
tick(call,
tÌ‚) = first k (call : tÌ‚)

Constraints from soundness

The standard soundness theorem requires that the abstract semantics simulate the concrete semantics; the key inductive step shows
simulation across a single transition:

(cÌ‚,ÏƒÌ‚)âˆˆSÌ‚ 0

[This formulation of the transfer function assumes that the store
grows monotonically across transition, i.e., that (. . . , ÏƒÌ‚, tÌ‚) ;
(. . . , ÏƒÌ‚ 0 , t0 ) implies ÏƒÌ‚ v ÏƒÌ‚ 0 .]
To compute the complexity of this analysis, note the isomorphism in the system-space:

Theorem 3.1. If Ï‚ â‡’ Ï‚ 0 and Î±(Ï‚) v Ï‚Ë†, then there must exist an
abstract state Ï‚Ë†0 such that: Ï‚Ë† â‡’ Ï‚Ë†0 and Î±(Ï‚ 0 ) v Ï‚Ë†0 .
The proof reduces to two lemmas which must be proved for
[:
\ Addr and Addr
every choice of the sets Time, Time,

â€œ
â€œ
â€â€ â€œ
â€œ
â€â€
d
[ â†’ P Clo
\ Ã— Time
\
ÎžÌ‚ âˆ¼
Ã— Addr
,
= Call â†’ P BEnv

Because the function fË† is monotonic, the height of the lattice ÎžÌ‚:

d
Lemma 3.2. If Î±(t) v tÌ‚, then Î±(tick(call , t)) v tick(call
, tÌ‚).

\|
|BEnv

[ tÌ‚).
Lemma 3.3. If Î±(t) v tÌ‚, then Î±(alloc(v, t)) v alloc(v,
3.5.1 The k-CFA solution
k-CFA represents one solution to the Simulation Lemmas 3.2 and
3.3. In k-CFA, a concrete time-stamp is the sequence of call sites
traversed since the start of the program; an abstract time-stamp is
the last k call sites. An address is a variable plus its binding time:
Time = Callâˆ—

\ = Callk
Time

Addr = Var Ã— Time

[ = Var Ã— Time.
\
Addr

\
|Time|

z
}|
{ z }| {
|Call| Ã— |Call|kÃ—|Var| Ã— |Call|k
[|
|Addr

d
|Clo|

}|
{
z
}|
{ z
+ |Var| Ã— |Call|k Ã— |Lam| Ã— |Call|kÃ—|Var| ,
3 Because alloc(v,
[
t) = (v, t), we could encode every binding environ-

\| =
ment with a map from variables to just times, so that, effectively, |BEnv
\ = |Time|
\ |Var| = |Call|kÃ—|Var| .
|Var * Time|

309

C : ClassName â†’ (FieldNameâˆ— Ã— Ructor )

Ï‚ âˆˆ Î£ = Stmt Ã— BEnv Ã— Store Ã— KontPtr Ã— Time
Î² âˆˆ BEnv = Var * Addr

fields

arguments

field values

record

z }| {
z}|{
z }| {
z }| {
K âˆˆ Ructor = Addr âˆ— Ã— Dâˆ— â†’ ( Store Ã— BEnv )

Ïƒ âˆˆ Store = Addr * D
d âˆˆ D = Val

M : D Ã— MethodCall * Method

val âˆˆ Val = Obj + Kont

Figure 5. Helper functions for the concrete semantics.

o âˆˆ Obj = ClassName Ã— BEnv
Îº âˆˆ Kont = Var Ã— Stmt Ã— BEnv Ã— KontPtr

It is important to note the encoding of objects: objects are a class
plus a record of their fields, and the record component is encoded
as a binding environment that maps field names to their addresses.
This encoding is congruent to k-CFAâ€™s encoding of closures, but it
is probably not the way one would encode the record component
of an object if starting from scratch. The natural encoding would
reduce an object to a class plus a single base address, i.e., Obj =
ClassName Ã— Addr , since fields are accessible as offsets from
the base address. Then, given an object (C, a), the address of
field f would be (f, a). In fact, under our semantics, given an
object (C, Î²), it is effectively the case that Î²(f ) = (f, a). We are
choosing the functional representation of records to maintain the
closest possible correspondence with CPS. When investigating the
complexity of k-CFA for Java, we will exploit this observation: the
fact that objects can be represented with just a base address causes
the collapse in complexity.
The concrete semantics are encoded as a small-step transition
relation (â‡’) âŠ† Î£ Ã— Î£. Each expression type gets a transition rule.
Object allocation creates a new binding environment Î² 0 , which
shares no structure with the previous environment Î²; contrast this
with CPS. These rules use the helper functions described in Figure 5. The constructor-lookup function C yields the field names and
the constructor associated with a class name. A constructor K takes
newly allocated addresses to use for fields and a vector of arguments; it returns the change to the store plus the record component
of the object that results from running the constructor. The methodlookup function M takes a method invocation point and an object
to determine which method is actually being called at that point.

a âˆˆ Addr is a set of addresses
Îº

p âˆˆ KontPtr âŠ† Addr
t âˆˆ Time is a set of time-stamps.

Figure 4. Concrete state-space for A-Normal Featherweight Java.
bounds the maximum number of times we may have to apply the
abstract transfer function. For k = 0, the height of the lattice is
quadratic in the size of the program (with the cost of applying the
transfer function linear in the size of the program). For k â‰¥ 1,
however, the algorithm has a genuinely exponential system-space.

4.

Shiversâ€™s k-CFA for Java

Having formulated a small-step k-CFA for CPS, it is straightforward to formulate a small-step, abstract interpretive k-CFA
for Java. To simplify the presentation, we utilize Featherweight
Java [7] in â€œA-Normalâ€ form. A-Normal Featherweight Java is
identical to ordinary Featherweight Java, except that arguments
to a function call must be atomically evaluable, as they are
in A-Normal Form Î»-calculus. For example, the body return
f.foo(b.bar()); becomes the sequence of statements B b1 =
b.bar(); F f1 = f.foo(b1); return f1;. This shift does
not change the expressive power of the language or the nature of the
analysis, but it does simplify the semantics by eliminating semantic
expression contexts. The following grammar describes A-Normal
Featherweight Java; note the (re-)introduction of statements:
âˆ’âˆ’âˆ’âˆ’â†’
âˆ’
â†’
Class ::= class C extends C 0 {C 00 f ; K M }
âˆ’
â†’
âˆ’
âˆ’
âˆ’
âˆ’
âˆ’
âˆ’
âˆ’
âˆ’
âˆ’âˆ’âˆ’â†’
âˆ’âˆ’â†’
K âˆˆ Konst ::= C (C f ){super( f 0 ) ; this.f 00 = f 000 ;}
âˆ’âˆ’â†’
âˆ’âˆ’âˆ’â†’
M âˆˆ Method ::= C m (C v ) { C v ; ~s }

4.2

s âˆˆ Stmt ::= v = e ;` | return v ;`
â†’
â†’
e âˆˆ Exp ::= v | v.f | v.m(âˆ’
v ) | new C (âˆ’
v ) | (C)v
f âˆˆ FieldName = Var
C âˆˆ ClassName is a set of class names
m âˆˆ MethodCall is a set of method invocation sites
` âˆˆ Lab is a set of labels

The set Var contains both variable and field names. Every statement
has a label. The function succ : Lab * Stmt yields the subsequent
statement for a statementâ€™s label.
4.1

Abstract semantics: k-CFA for Featherweight Java

Figure 7 contains the abstract state-space for the small-step Featherweight Java machine, i.e., OO k-CFA. As was the case for CPS,
the abstract semantics closely mirror the concrete semantics. We
assume the natural partial order for the components of the abstract
state-space.
The abstract semantics are encoded as a small-step transition
relation (;) âŠ† Î£Ì‚ Ã— Î£Ì‚, shown in Figure 9. There is one abstract
transition rule for each expression type, plus an additional transition
rule to account for return. These rules make use of the helper
functions described in Figure 8. The constructor-lookup function CË†
yields the field names and the abstract constructor associated with
a class name. An abstract constructor KÌ‚ takes abstract addresses to
use for fields and a vector of arguments; it returns the â€œchangeâ€ to
the store plus the record component of the object that results from
running the constructor. The abstract method-lookup function MÌ‚
takes a method invocation point and an object to determine which
methods could be called at that point.

Concrete semantics for Featherweight Java

Figure 4 contains the concrete state-space for the small-step Featherweight Java machine, and Figure 6 contains the concrete semantics.4 The state-space closely resembles the concrete state-space for
CPS. One difference is the need to explicitly allocate continuations
(from the set Kont) at a semantic level. These same continuations
exist in CPS, but theyâ€™re hidden in plain sightâ€”the CPS transform
converts semantic continuations into syntactic continuations.

4.3 The k-CFA solution
As in the original k-CFA for CPS, we factored out time-stamp and
address allocation functions and even the structure of time-stamps
and addresses. The equivalent to call sites in Java are statements.
So, a concrete time-stamp is the sequence of labels traversed since
the program began execution. Addresses pair either a variable/field
name or a method with a time. Method names are allowed, so that
continuations can have a binding point for each method at each

4 Note that the (+) operation represents right-biased functional union, and

that wherever a vector ~
x is in scope, its components are implicitly in scope:
~
x = hx0 , . . . , xlength(xÌƒ ) i.

310

Variable reference
Îº

Îº

([[v = v 0 ;` ]], Î², Ïƒ, p , t) â‡’ (succ(`), Î², Ïƒ 0 , p , t0 ), where
t0 = tick(`, t)

\ )
CË† : ClassName â†’ (FieldNameâˆ— Ã— Ructor

Ïƒ 0 = Ïƒ[Î²(v) 7â†’ Ïƒ(Î²(v 0 ))].

âˆ—

[ Ã— DÌ‚âˆ— â†’ (Store
\ = Addr
[ Ã— BEnv
\)
KÌ‚ âˆˆ Ructor

Return
Îº0

Îº

([[return v ;` ]], Î², Ïƒ, p , t) â‡’ (s, Î² 0 , Ïƒ 0 , p , t0 ), where
Îº0

t0 = tick(`, t)

b Ã— MethodCall â†’ P (Method)
MÌ‚ : D

Îº

(v 0 , s, Î² 0 , p ) = Ïƒ(p )

Figure 8. Helper functions for the abstract semantics.

Ïƒ 0 = Ïƒ[Î² 0 (v 0 ) 7â†’ d].

d = Ïƒ(Î²(v))

Field reference
Îº

Îº

([[v = v 0 .f ;` ]], Î², Ïƒ, p , t) â‡’ (succ(`), Î², Ïƒ 0 , p , t0 ), where
t0 = tick(`, t)

(C, Î² 0 ) = Ïƒ(Î²(v 0 ))

Ïƒ 0 = Ïƒ[Î²(v) 7â†’ Ïƒ(Î² 0 (f ))].

Method invocation

Variable reference

âˆ’
â†’
Îº
Îº0
([[v = v0 .m( v 0 );` ]], Î², Ïƒ, p , t) â‡’ (s0 , Î² 00 , Ïƒ 0 , p , t0 ),
where
âˆ’âˆ’âˆ’â†’ âˆ’âˆ’âˆ’âˆ’âˆ’â†’
M = [[C m (C v 00 ) {C 0 v 000 ; ~s}]] = M(d0 , m)
t = tick(`, t)
000 0
a00
j = alloc(vj , t )

Î² = [[[this]] 7â†’ Î²(v0 )]

Î² 00 = Î² 0 [vi00 7â†’ a0i , vj000 7â†’ a00
j]

Ïƒ 0 = Ïƒ[p 7â†’ Îº, a0i 7â†’ di ].

ÎºÌ‚

d tÌ‚)
tÌ‚0 = tick(`,

d0 = (C, Î² 0 )

Ïƒ 0 = Ïƒ + âˆ†Ïƒ + [Î²(v) 7â†’ d0 ].

Casting
t = tick(`, t)

0

dË†0 = ÏƒÌ‚(Î²Ì‚(v0 ))

dË†i = ÏƒÌ‚(Î²Ì‚(vi0 ))

d tÌ‚)
tÌ‚0 = tick(`,

ÎºÌ‚ = (v, succ(`), Î²Ì‚, p )

ÎºÌ‚

ÎºÌ‚ 0

Îº

([[v = (C 0 ) v 0 ]], Î², Ïƒ, p , t) â‡’ (succ(`), Î², Ïƒ 0 , p , t0 ), where
0

ÏƒÌ‚ 0 = ÏƒÌ‚ t [Î²Ì‚(v) 7â†’ ÏƒÌ‚(Î²Ì‚ 0 (f ))].

âˆ’
â†’
ÎºÌ‚ 0
ÎºÌ‚
([[v = v0 .m( v 0 );` ]], Î²Ì‚, ÏƒÌ‚, p , tÌ‚) ; (s0 , Î²Ì‚ 00 , ÏƒÌ‚ 0 , p , tÌ‚0 ),
where
âˆ’âˆ’âˆ’â†’ âˆ’âˆ’âˆ’âˆ’âˆ’â†’
M = [[C m (C v 00 ) {C 0 v 000 ; ~s}]] âˆˆ M(dË†0 , m)

ai = alloc(fi , t0 )

Îº

(C, Î²Ì‚ 0 ) âˆˆ ÏƒÌ‚(Î²Ì‚(v 0 ))

Method invocation

di = Ïƒ(Î²(vi0 ))

~
(âˆ†Ïƒ, Î² ) = K(~a, d)

ÎºÌ‚

([[v = v 0 .f ;` ]], Î²Ì‚, ÏƒÌ‚, p , tÌ‚) ; (succ(`), Î²Ì‚, ÏƒÌ‚ 0 , p , tÌ‚0 ), where

âˆ’
â†’
Îº
Îº
([[v = new C ( v 0 );` ]], Î², Ïƒ, p , t) â‡’ (succ(`), Î², Ïƒ 0 , p , t0 ),
where

0

Ë†
ÏƒÌ‚ 0 = ÏƒÌ‚ t [Î²Ì‚ 0 (v 0 ) 7â†’ d].

Field reference

Object allocation

(f~, K) = C(C)

ÎºÌ‚

(v 0 , s, Î²Ì‚ 0 , p ) âˆˆ ÏƒÌ‚(p )

dË† = ÏƒÌ‚(Î²Ì‚(v))

Îº0

t0 = tick(`, t)

ÎºÌ‚ 0

d tÌ‚)
tÌ‚0 = tick(`,

a0i = alloc(vi00 , t0 )
0

p = alloc Îº (M, t )

ÎºÌ‚ 0

ÎºÌ‚

([[return v ;` ]], Î²Ì‚, ÏƒÌ‚, p , tÌ‚) ; (s, Î²Ì‚ 0 , ÏƒÌ‚ 0 , p , tÌ‚0 ), where

Îº = (v, succ(`), Î², p )
0

ÏƒÌ‚ 0 = ÏƒÌ‚ t [Î²Ì‚(v) 7â†’ ÏƒÌ‚(Î²Ì‚(v 0 ))].

Return

Îº

0

ÎºÌ‚

d tÌ‚)
tÌ‚0 = tick(`,

di = Ïƒ(Î²(vi0 ))

d0 = Ïƒ(Î²(v0 ))
Îº0

ÎºÌ‚

([[v = v 0 ;` ]], Î²Ì‚, ÏƒÌ‚, p , tÌ‚) ; (succ(`), Î²Ì‚, ÏƒÌ‚ 0 , p , tÌ‚0 ), where

0

Ïƒ = Ïƒ[Î²(v) 7â†’ Ïƒ(Î²(v ))].

Figure 6. Concrete semantics for A-Normal Featherweight Java.

[ ÎºÌ‚ (M, tÌ‚0 )
p = alloc

[ i00 , tÌ‚0 )
aÌ‚0i = alloc(v

[ 000 0
aÌ‚00
j = alloc(vj , tÌ‚ )

Î²Ì‚ 0 = [[[this]] 7â†’ Î²Ì‚(v0 )]

Î²Ì‚ 00 = Î²Ì‚ 0 [vi00 7â†’ aÌ‚0i , vj000 7â†’ aÌ‚00
j]

ÎºÌ‚
ÏƒÌ‚ 0 = ÏƒÌ‚ t [p 7â†’ {ÎºÌ‚} , aÌ‚0i 7â†’ dË†i ].

0

Object allocation
âˆ’
â†’
ÎºÌ‚
ÎºÌ‚
([[v = new C ( v 0 );` ]], Î²Ì‚, ÏƒÌ‚, p , tÌ‚) ; (succ(`), Î²Ì‚, ÏƒÌ‚ 0 , p , tÌ‚0 ),
where

\ Ã— Store
[ Ã— KontPtr
\ Ã— Time
\
Ï‚Ë† âˆˆ Î£Ì‚ = Stmt Ã— BEnv
[
\ = Var * Addr
Î²Ì‚ âˆˆ BEnv

d tÌ‚)
tÌ‚0 = tick(`,

b
[ â†’D
[ = Addr
ÏƒÌ‚ âˆˆ Store
â€œ
â€
d
dË† âˆˆ DÌ‚ = P Val

dË†i = ÏƒÌ‚(Î²Ì‚(vi0 ))
[ i , tÌ‚0 )
aÌ‚i = alloc(f

Ë†
(f~, KÌ‚) = C(C)
~Ë†
(âˆ†ÏƒÌ‚, Î²Ì‚ 0 ) = KÌ‚(~aÌ‚, d)

c âˆˆ Val
d = Obj
d + Kont
[
val

dË†0 = (C, Î²Ì‚ 0 )

ÏƒÌ‚ 0 = ÏƒÌ‚ t âˆ†ÏƒÌ‚ t [Î²Ì‚(v) 7â†’ dË†0 ].

d = ClassName Ã— BEnv
\
oÌ‚ âˆˆ Obj

Casting

[ = Var Ã— Stmt Ã— BEnv
\ Ã— KontPtr
\
ÎºÌ‚ âˆˆ Kont

ÎºÌ‚

ÎºÌ‚

([[v = (C 0 ) v 0 ]], Î²Ì‚, ÏƒÌ‚, p , tÌ‚) ; (succ(`), Î²Ì‚, ÏƒÌ‚ 0 , p , tÌ‚0 )

[ is a finite set of addresses
aÌ‚ âˆˆ Addr

d tÌ‚)
tÌ‚0 = tick(`,

ÎºÌ‚

[
\ âŠ† Addr
p âˆˆ KontPtr

ÏƒÌ‚ 0 = ÏƒÌ‚ t [Î²Ì‚(v) 7â†’ ÏƒÌ‚(Î²Ì‚(v 0 ))].

Figure 9. Abstract semantics for A-Normal Featherweight Java.

\ is a finite set of time-stamps.
tÌ‚ âˆˆ Time

Figure 7. Abstract state-space for A-Normal Featherweight Java.

311

optimization technique for functional languages: flat-environment
closures [1, 3]. In flat-environment closures, the values of all free
variables are copied directly into the new environment. As a result,
one needs to keep track of only the base address of the environment:
any free variable is accessed as an offset.
This flat-environment re-engineering leads to the desired polynomiality, an outcome first noted in the universal framework of Jagannathan and Weeks [8] (here â€œJWâ€ for brevity). Some caution
must be taken in the use of flat environments; if used in conjunction
with Shiversâ€™s k-CFA-style â€œlast-k-call-sitesâ€ contour-allocation
strategy, flat environments achieve weak context-sensitivity in practice (Section 6). Jagannathan and Weeks suggest several contour
abstractions for control-flow analyses, including using the last k
call sites and the top m frames of the stack. Section 6 argues quantitatively and qualitatively that the top-m-frames approach is the
right abstraction for flat environments. To distinguish this approach
from other possible instantiations of the JW framework, we term
the resulting hierarchy m-CFA. Additionally, we note that it is important to specify m-CFA explicitly, as we do below, since its form
does not straightforwardly follow from past results. Specifically,
Jagannathan and Weeks do specify the abstract domains necessary
for a stack-based â€œpolynomial k-CFAâ€ but do not give an explicit
abstract semantics that would produce the results of their examples. This is significant because simply adapting the JW concrete
semantics to the abstract domains would not produce m-CFA (or
any other reasonable static analysis). The analysis cannot just â€œpopâ€
stack frames when a finite prefix of the call-stack is kept. For instance, when the current context abstraction consists of call-sites
(f , g), popping the last call-site will result in a one-element stack.
What our analysis needs to do instead (on a function return) is restore the abstract environment of the current caller.

time. (Were method names not allowed, then all procedures would
return to the same continuations in â€œ0â€CFA.)
Time = Labâˆ—

\ = Labk
Time

Addr = Offset Ã— Time

[ = Offset Ã— Time
\
Addr

Offset = Var + Method.

The time-stamp function prepends the most recent label. The
variable/field-allocation function pairs the variable/field with the
current time, while the continuation-allocation function pairs the
method being invoked with the current time:
tick (`, t) = ` : t

4.4

d tÌ‚) = first (` : tÌ‚)
tick(`,
k

alloc(v, t) = (v, t)

[
alloc(v,
tÌ‚) = (v, tÌ‚)

alloc Îº (M, t) = (M, t)

[ ÎºÌ‚ (M, tÌ‚) = (M, tÌ‚).
alloc

Computing k-CFA for Featherweight Java

When we apply the single-threaded store optimization for k-CFA
over Java, the state-space appears to be genuinely exponential for
k â‰¥ 1. This is because the analysis affords more precision and
control over individual fields than is normally expected of a pointer
analysis. Under k-CFA, the address of every field is the field name
paired with the abstract time from its moment of allocation; the
same is true of every procedure parameter. However, these fields
are still stored within maps, and these maps are the source of the
apparent complexity explosion.
Fortunately, by inspecting the semantics, we see that every address in the range of a binding environment shares the same time.
\ ) may be replaced directly by
Thus, binding environments (BEnv
\âˆ¼
the time of allocation with no loss of precision. In effect, BEnv
=
\
Time for object-oriented programs. Simplifying the semantics under this assumption leads to an abstract system-space with a polynomial number of bits to (monotonically) flip for a fixed k:
\ 3 Â· |Method| + |Method + Var| Â· |Time|
|Stmt| Â· |Time|
Â· (|Class| Â· |Time| + |Var| Â· |Stmt| Â· |Time| Â· |Method| Â· |Time|)

5.1 A concrete semantics with flat closures
In the new state-space, an environment is a base address:

By constructing Shiversâ€™s k-CFA for Java, and noting the subtle
difference between the semanticsâ€™ handling of closures and objects,
we have exposed the root cause of the discrepancy in complexity.
In the next section, we profit from this observation by constructing a semantics in which closures behave like objects, resulting in
a polynomial-time, context-sensitive hierarchy of CFAs for functional programs.
4.5

Ï‚ âˆˆ Î£ = Call Ã— Env Ã— Store
Ïƒ âˆˆ Store = Addr * D
d âˆˆ D = Clo
clo âˆˆ Clo = Lam Ã— Env
a âˆˆ Addr = Var Ã— Env

Variations

Ï âˆˆ Env is a set of base environment addresses.

The above form of k-CFA is not exactly what would be usually
called a k-CFA points-to analysis in OO languages. Specifically,
OO k-CFAs would typically not change the context for each statement but only for method invocation statements. An OO k-CFA is
a call-site-sensitive points-to analysis: the only context maintained
is call-sites. That is, abstract time would not â€œtickâ€, except in the
method invocation rule of Figure 9. Furthermore, the callerâ€™s context would be restored on a method return, instead of just advancing
the abstract time to its next step. (This choice is discussed extensively in the next sections.) These variations, however, are orthogonal to our main point: The algorithm is polynomial because of the
simultaneous closing of all fields of an object.

The expression-evaluator E : Exp Ã— Env Ã— Store * D creates
a closure over the current environment:
E(v, Ï, Ïƒ) = Ïƒ(v, Ï)

E(lam, Ï, Ïƒ) = (lam, Ï).

There is only one transition rule; when call = [[(f e1 . . . en )]]:
(call , Ï, Ïƒ) â‡’ (call 0 , Ï00 , Ïƒ 0 ), where
(lam, Ï0 ) = E(f, Ï, Ïƒ)

5. m-CFA: Context-sensitive CFA in PTIME

lam = [[(Î» (v1 . . . vn ) call 0 )]]

k-CFA for object-oriented programs is polynomial-time because
it collapses the records inside objects into base addresses. It is
possible to re-engineer the semantics of the Î»-calculus so that we
achieve a similar collapse with the environments inside closures.
In fact, the re-engineering corresponds to a well-known compiler

{x1 , . . . , xm } = free(lam)
00

axj = (xj , Ï )
Ïƒ 0 = Ïƒ[avi 7â†’ di ][axj 7â†’ d0j ].

312

di = E(ei , Ï, Ïƒ)
Ï00 = new (call, Ï)
avi = (vi , Ï00 )
d0j = Ïƒ(xj , Ï0 )

By setting Env = N Ã— Callâˆ— , it is straightforward to construct
a concrete allocator that the abstract allocator simulates:

5.2 Abstract semantics: m-CFA
The abstract state-space is similar to the concrete:

0

~
~ )) =
new (call, (n, call),
lam, (n0 , call
(
~
(n + 1, call : call) lam is a procedure
~ 0)
(n + 1, call
lam is a continuation.

d Ã— Store
[
Ï‚Ë† âˆˆ Î£Ì‚ = Call Ã— Env
b
[ *D
[ = Addr
ÏƒÌ‚ âˆˆ Store
â€œ
â€
d
dË† âˆˆ DÌ‚ = P Clo
c âˆˆ Clo
d = Lam Ã— Env
d
clo

5.4 Computing m-CFA
Consider the single-threaded system-space for m-CFA:

d
[ = Var Ã— Env
aÌ‚ âˆˆ Addr

â€œ
â€
d Ã— Store
[
ÎžÌ‚ = P Call Ã— Env
â€œ
â€œ
â€â€ â€œ
â€œ
â€â€
d
âˆ¼
d
Ã— Addr â†’ P Clo
.
= Call â†’ P Env

d is a set of base environments addresses.
ÏÌ‚ âˆˆ Env

d Ã— Store
b also mirrors
[ â†’D
The abstract evaluator EÌ‚ : Exp Ã— Env
the concrete semantics:
EÌ‚(v, ÏÌ‚, ÏƒÌ‚) = ÏƒÌ‚(v, ÏÌ‚)

Theorem 5.1. Computing m-CFA is complete for PTIME.

EÌ‚(lam, ÏÌ‚, ÏƒÌ‚) = {(lam, ÏÌ‚)} .

Proof. Computing m-CFA is a monotonic ascent through a lattice
whose height is polynomial in program size:

There is only one transition rule; when call = [[(f e1 . . . en )]]:
(call , ÏÌ‚, ÏƒÌ‚) â‡’ (call 0 , ÏÌ‚00 , ÏƒÌ‚ 0 ), where
(lam, ÏÌ‚0 ) âˆˆ EÌ‚(f, ÏÌ‚, ÏƒÌ‚)
lam = [[(Î» (v1 . . . vn ) call 0 )]]

aÌ‚xj = (xj , ÏÌ‚00 )

ÏÌ‚00 = new
d (call, ÏÌ‚, lam, ÏÌ‚0 )

aÌ‚vi = (vi , ÏÌ‚00 )
dË†0 = ÏƒÌ‚(xj , ÏÌ‚0 )

{x1 , . . . , xm } = free(lam)

|Call| Ã— |Call|m Ã— |Var| Ã— |Call|m Ã— |Lam| Ã— |Call|m .

dË†i = EÌ‚(ei , ÏÌ‚, ÏƒÌ‚)

Clearly, for any choice of m â‰¥ 0, m-CFA is computable in
polynomial time. Hardness follows from the fact that [m = 0]CFA
and [k = 0]CFA are the same analysis, which is known to be
PTIME-hard [18].

j

ÏƒÌ‚ 0 = ÏƒÌ‚ t [aÌ‚vi 7â†’ dË†i ] t [aÌ‚xj 7â†’ dË†0j ].
5.3

6.

This work draws heavily on the Cousotsâ€™ abstract interpretation [4,
5] and upon Shiversâ€™s original formulation of k-CFA [17]. mCFA (assuming suitable widening) can be viewed as an instance
of the universal framework of Jagannathan and Weeks [8], but for
continuation-passing style. If one naively uses the framework of Jagannathan and Weeks [8] with Shiversâ€™s k-CFA contour-allocation
strategy, the result is a polynomial CFA algorithm that uses a â€œlastk-call-sitesâ€ context abstraction, unlike our m-CFA, which uses a
top-m-frames abstraction. In the rest of this section, â€œnaive polynomial k-CFAâ€ refers to a flat-environment CFA with a last-k-callsites abstraction.
We will argue next, both qualitatively and quantitatively, why
the top-m-frame abstraction is better than the last-k-call abstraction
for the case of flat-environment CFAs. The distinction between
these policies is subtle yet important. Using the last k call sites
forces environments within a functionâ€™s scope to merge after the
kth (direct or indirect) call made by a function. Any recursive
function will appear to make at least k calls during an analysis,
leaving only leaf procedures with boosted context-sensitivity; since
leaf procedures do not invoke higher-order functions, the extra
context-sensitivity offers no benefit to control-flow analysis.
Consider, for example, the invocation of a simple function:

Context-sensitivity

The parameter which must be fixed for m-CFA is the new environment allocator. To construct the right kind of context-sensitive
analysis, we will work backwardâ€”from the abstract to the concrete. We would like it to be the case that when a procedure is
invoked, bindings to its parameters are separated from other bindings based on calling context. In addition, we need it to be the case
that procedures return to the calling context in which they were
invoked. (Bear in mind that â€œreturningâ€ in CPS means calling the
continuation argument.) Directly allocating the last k call sites, as
in k-CFA, does not achieve the desired effect, because variables
get repeatedly rebound during the evaluation of a procedure with
each invocation of an internal continuation. This causes variables
from separate invocations to merge once they are k calls into in the
procedure. Counterintuitively, we solve this problem by allocating
fewer abstract environments. We want to allocate a new environment when a true procedure is invoked, and we want to restore
an old environment when a continuation is invoked. As a result,
m-CFA is sensitive to the top m stack frames, whereas k-CFA is
sensitive to the last k calls.5
In this case, environments will be a function of context, so we
have environments play the role of time-stamps in k-CFA:

(identity 3)

m
d = Call
[ ,
Env

If the definition of the identity function is:

m-CFA assumes and exploits the well-known partitioning of the
CPS grammar from âˆ†CFA [12] which syntactically distinguishes
ordinary procedures from continuations:
(
new
d (call, ÏÌ‚, lam, ÏÌ‚0 ) =

Comparisons to related analyses

(define (identity x) x)
then both naive polynomial 1CFA and [m = 1]CFA return the same
flow analysis as [k = 1]CFA for the program:

first m (call : ÏÌ‚) lam is a procedure
ÏÌ‚0
lam is a continuation.

(id 3)
(id 4)

From this it is clear that [m = 0]CFA and [k = 0]CFA are actually
the same context-insensitive analysis.

That is, all agree the return value is 4. If, however, we add a seemingly innocuous function call to the body of the identity function:
(define (identity x)
(do-something)
x)

5 Consider a program which calls a, calls b and then returns from b. [k =

1]CFA will consider the context to be the call to b, while [m = 1]CFA will
consider the context to be the call to a.

313

 indicates that the analysis returned in less than one second; âˆž
indicates the analysis took longer than one hour.
As can be seen, m-CFA is not just faster than k-CFA but also
consistently faster than naive polynomial k-CFA. The difference
in scalability between m-CFA and k-CFA is large and matches
the theoretical expectations well. From these numbers we can infer that, in the worst case, the feasible range of context-sensitive
analysis of functional programs has been increased by two-to-three
orders of magnitude.

then polynomial 1CFA would say that the program returns 3 or 4,
whereas [m = 1]CFA and [k = 1]CFA still agree that the return
value is just 4.
To understand why naive polynomial 1CFA degenerates into
the behavior of 0CFA with the addition of the function call to
do-something, consider what the last k = 1 call sites are at the
return point x. Without the intervening call to (do-something),
the last call site at this point was (id 3) in the first case, and (id
4) in the second case. Thus, polynomial 1CFA keeps the bindings
to x distinct. With the intervening call to (do-something), the
last call site becomes (do-something) in both cases, causing the
flow sets for x to merge together. If, however, we allocate the top
m stack frames for the environment, then the intervening call to
do-something has no effect, because the top of the stack at the
return point x is still the call to (id 3) or (id 4), which keeps
the bindings distinct.
Several papers have investigated polyvariant flow analyses with
polynomial complexity bounds in the setting of type-based analysis, as compared with the abstract interpretation approach employed in this paper. Mossin [14] presents a flow analysis based
on polymorphic subtyping including polymorphic recursion for a
simply-typed (i.e. monomorphically typed) Î»-calculus. Mossinâ€™s
algorithm operates in O(n8 )-time and both Rehof and FaÌˆhndrich
[15] and Gustavsson and Svenningsson [6] developed alternative
algorithms that operate in O(n3 ), where n is the size of the explicitly typed program (and in the worst case, types may be exponentially larger than the programs they annotate). m-CFA does not impose typability assumptions and is polynomial in the program size
without type annotations. As a consequence of the abstract interpretation approach taken in m-CFA, unreachable parts of the program are never analyzed, in contrast to most type based approaches.
Another difference concerns the space of abstract values: m-CFA
includes closure approximations, while polymorphic recursive flow
types relate program text and do not predict run-time environment
structure.
6.1

6.2

Prog/
Terms
eta
49
map
157
sat
223
regex
1015
scm2java
2318
interp
4289
scm2c
6219

Benchmark-driven comparisons

7.

The constructive content of Van Horn and Mairsonâ€™s proof offers a
way to generate benchmarks that exercise the worst-case behavior
of a CFAâ€”by constructing a program that forces the CFA to the top
of the lattice (because the most precise possible answer is the top).
Using this insight, we constructed a series of successively larger
â€œworst-caseâ€ benchmarks and recorded how long it took each CFA
to reach the top of the lattice on a 2 Core, 2 GHz OS X machine:
k=1


46 s
âˆž
âˆž
âˆž

m=1



3s
48 s
51 m

poly.,k=1


2s
5s
1m8s
âˆž

m=1

poly.,k=1

k=0



7



7



3



3



8



8



8



6

âˆž

-



12

1s

12



12

4s

25

3s

25

14s

25

2s

25

5s

86

3s

86

3s

79

4s

79

5s

123

4s

123

9s

123

5s

123

179s

136

143s

136

157s

131

55s

131

Conclusion

Our investigation began with the k-CFA paradox: the apparent contradiction between (1) Van Horn and Mairsonâ€™s proof that k-CFA
is EXPTIME-complete for functional languages and (2) the existence of provably polynomial-time implementations of k-CFA
for object-oriented languages. We resolved the paradox by showing that the same abstraction manifests itself differently for functional and object-oriented languages. To do so, we faithfully reconstructed Shiversâ€™s k-CFA for Featherweight Java, and then found
that the mechanism used to represent closures is degenerate for the
semantics of Java. This degeneracy is what causes the collapse into
polynomial time.
With respect to standard practice in k-CFA, the bindings inside
closures may be introduced over time in several contexts, whereas
the fields inside an object are all allocated in the same context.
This allows objects to be represented as a class name plus the
initial context, whereas the environments inside closures must be
a true map from variables to binding contexts; this map causes the
exponential blow-up in complexity for functional k-CFA. Armed
with this insight, we constructed a concrete semantics for the Î»calculus which uses flat environmentsâ€”environments in which free

Comparing speed with precision held constant

Terms
69
123
231
447
879
1743

k=1

The first two benchmarks test common functional idioms; sat is
a back-tracking SAT-solver; regex is a regular expression matcher
based on derivatives; scm2java is a Scheme compiler that targets
Java; interp is a meta-circular Scheme interpreter; scm2c is a
Scheme compiler that targets C.
From these experiments, m-CFA appears to be as precise as kCFA in practice, but at a fraction of the cost. Compared to naive
polynomial 1CFA, [m = 1]CFA is always equally fast or faster and
equally or more precise. These experiments also suggest that naive
polynomial 1CFA is little better than 0CFA in practice, and, in fact,
it even incurs a higher running time than k-CFA in some cases.

We have implemented k-CFA, m-CFA and polynomial k-CFA for
R5RS Scheme (with support for some of R6RS). Making a fair
comparison of unrelated CFAs (e.g., m-CFA and polynomial kCFA) is not straightforward. CFAs are not totally ordered by either
speed or precision for all programs. In fact, even within the same
program, two CFAs may each be locally more precise at different
points in the program. That is, given the output of two CFAs,
it might not always be possible to say one is more precise than
another. To compare CFAs on an â€œapples-to-applesâ€ basis requires
careful benchmark construction; we discuss the results on such
benchmarks below.
6.1.1

Comparing speed and precision

On the following benchmarks, we measured both the run-time of
the analyses and the number of inlinings supported by the results.
We are using the number of inlinings supported as a crude but
immediately practical metric of the precision of the analysis.

k=0



2s
15 s
3 m 48 s

314

[4] Patrick Cousot and Radhia Cousot. Abstract interpretation: A unified
lattice model for static analysis of programs by construction or approximation of fixpoints. In Conference Record of the Fourth ACM Symposium on Principles of Programming Languages, pages 238â€“252. ACM
Press, 1977.
[5] Patrick Cousot and Radhia Cousot. Systematic design of program
analysis frameworks. In POPL â€™79: Proceedings of the 6th ACM
SIGACT-SIGPLAN Symposium on Principles of Programming Languages, pages 269â€“282. ACM Press, 1979.
[6] JoÌˆrgen Gustavsson and Josef Svenningsson. Constraint abstractions.
In PADO â€™01: Proceedings of the Second Symposium on Programs
as Data Objects, pages 63â€“83. Springer-Verlag, 2001. ISBN 3-54042068-1.
[7] Atsushi Igarashi, Benjamin C. Pierce, and Philip Wadler. Featherweight Java: a minimal core calculus for Java and GJ. ACM Trans.
Program. Lang. Syst., 23(3):396â€“450, 2001. ISSN 0164-0925.
[8] Suresh Jagannathan and Stephen Weeks. A unified treatment of flow
analysis in higher-order languages. In POPL â€™95: Proceedings of the
22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 393â€“407. ACM, 1995. ISBN 0-89791-692-1.
[9] OndrÌŒej LhotaÌk. Program Analysis using Binary Decision Diagrams.
PhD thesis, McGill University, January 2006.
[10] OndrÌŒej LhotaÌk and Laurie Hendren. Evaluating the benefits of contextsensitive points-to analysis using a BDD-based implementation. ACM
Trans. Softw. Eng. Methodol., 18(1):1â€“53, 2008. ISSN 1049-331X.
[11] Jan Midtgaard. Control-flow analysis of functional programs. Technical Report BRICS RS-07-18, DAIMI, Department of Computer Science, University of Aarhus, December 2007. To appear in revised form
in ACM Computing Surveys.
[12] Matthew Might and Olin Shivers. Environment analysis via âˆ†-CFA.
In POPL â€™06: Conference record of the 33rd ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages, pages 127â€“
140. ACM, 2006. ISBN 1-59593-027-2.
[13] Matthew Might and Olin Shivers. Improving flow analyses via Î“CFA:
Abstract garbage collection and counting. In ICFP â€™06: Proceedings of
the Eleventh ACM SIGPLAN International Conference on Functional
Programming, pages 13â€“25. ACM, 2006. ISBN 1-59593-309-3.
[14] Christian Mossin. Flow Analysis of Typed Higher-Order Programs.
PhD thesis, DIKU, University of Copenhagen, January 1997.
[15] Jakob Rehof and Manuel FaÌˆhndrich. Type-base flow analysis: from
polymorphic subtyping to CFL-reachability. In POPL â€™01: Proceedings of the 28th ACM SIGPLAN-SIGACT Symposium on Principles of
Programming Languages, pages 54â€“66. ACM, 2001. ISBN 1-58113336-7.
[16] Olin Shivers. Higher-order control-flow analysis in retrospect: lessons
learned, lessons abandoned. In Kathryn S. McKinley, editor, Best of
PLDI 1988, volume 39, pages 257â€“269. ACM, 2004.
[17] Olin G. Shivers. Control-Flow Analysis of Higher-Order Languages.
PhD thesis, Carnegie Mellon University, 1991.
[18] David Van Horn and Harry G. Mairson. Relating complexity and
precision in control flow analysis. In ICFP â€™07: Proceedings of the
12th ACM SIGPLAN International Conference on Functional Programming, pages 85â€“96. ACM, 2007. ISBN 9781-59593-815-2.
[19] David Van Horn and Harry G. Mairson. Deciding kCFA is complete
for EXPTIME. In ICFP â€™08: Proceeding of the 13th ACM SIGPLAN
International Conference on Functional Programming, pages 275â€“
282. ACM, 2008. ISBN 9781-595-9391-9-7.

variables are accessed as offsets from a base pointer, rather than
through a chain of environments. In fact, this environment policy
corresponds to well-known implementation techniques from the
field of functional program compilation.
Under abstraction, flat environments exhibit the same degeneracy as objects, and the end result is a polynomial hierarchy of
context-sensitive control-flow analyses for functional languages.
Our empirical investigation found that coupling flat environments
with a last-k-call-sites policy for context-allocation offers negligible benefits for precision compared with 0CFA. To solve this problem, we constructed a polynomial CFA hierarchy which allocates
the top m stack frames as its context: m-CFA. According to our
empirical evaluation, m-CFA matches k-CFA in precision, but with
faster performance.

8.

Future work

Our intent with this work was to build a bridge. Now built, that
bridge spans the long-separated worlds of functional and objectoriented program analysis. Having already profited from the first
round-trip voyage, it is worth asking what else may cross.
We believe that abstract garbage collection is a good candidate [13]. At the moment, it has only been formulated for the functional world. The abstract semantics for Featherweight Java make
it possible to adapt abstract garbage collection to the static analysis
of object-oriented programs. We hypothesize that its benefits for
speed and precision will carry over.
Going in the other direction, the field of points-to analysis for
object-oriented languages has significant maturity and has developed a more practical understanding for what parameters (e.g.,
context depth) and approximations (e.g., maintaining different contexts for variables vs. closures) tend to yield fruitful precision for
client analyses. There is a more intense emphasis on implementation (e.g., using binary decision diagrams) and on evaluation,
which should be possible to translate to the functional setting. Also,
what the object-oriented community calls shape analysis appears
to go by environment analysis in the functional community. Peering across from the functional side of the bridge, shape analyses
seem far ahead of environment analyses in their sophistication. We
hypothesize that these shape-analytic techniques will be profitable
for environment analysis.
Acknowledgments: We are grateful to Jan Midtgaard for comments and relevant references to the literature. We thank OndrÌŒej
LhotaÌk for valuable discussions. This work was funded by the National Science Foundation under grant 0937060 to the Computing Research Association for the CIFellow Project, which supports David Van Horn, as well as grants CCF-0917774 and CCF0934631.

References
[1] Andrew W. Appel. Compiling with Continuations. Cambridge University Press, November 1991. ISBN 0-521-41695-7.
[2] Martin Bravenboer and Yannis Smaragdakis. Strictly declarative specification of sophisticated points-to analyses. In OOPSLA â€™09: 24th
annual ACM SIGPLAN conference on Object Oriented Programming,
Systems, Languages, and Applications, 2009.
[3] Luca Cardelli. Compiling a functional language. In LISP and Functional Programming, pages 208â€“217, 1984.

315

